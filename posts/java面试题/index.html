<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Java面试题 | Lilecloud Site</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别
sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 sleep 可以在任何地方被调用，wait只能在同步代码块中被调用 synchronized 关键字如何实现的
monitor 对象，加锁是monitorenter ,解锁是monitorexit 强引用，弱引用,虚引用，软引用
强引用： 内存不够的时候也不会释放，哪怕发生OOM 软引用：内存不够时GC就会释放 弱引用: 只要是GC 就会释放 虚引用：是最弱的引用，对对象无感有和没有一样，主要用来判断对象鉴活的应用，可以用来做对外内存的释放 ThreadLocal 会导致内存溢出，为什么
如果线程一直在使用，例如线程池中的线程，那么ThreadLocal引用的对象就不能被释放，导致内存泄漏 解决办法就是：在使用ThreadLcal 结束时调用remove 方法 框架 Redis redis 数据结构 String list set zset hash redis 哨兵和集群模式 哨兵模式会有 哨兵服务器来监视 所有节点，检测健康，当主节点宕机之后，哨兵负责选举出新的主节点"><meta name=generator content="Hugo 0.104.3"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="Java面试题"><meta property="og:description" content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别
sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 sleep 可以在任何地方被调用，wait只能在同步代码块中被调用 synchronized 关键字如何实现的
monitor 对象，加锁是monitorenter ,解锁是monitorexit 强引用，弱引用,虚引用，软引用
强引用： 内存不够的时候也不会释放，哪怕发生OOM 软引用：内存不够时GC就会释放 弱引用: 只要是GC 就会释放 虚引用：是最弱的引用，对对象无感有和没有一样，主要用来判断对象鉴活的应用，可以用来做对外内存的释放 ThreadLocal 会导致内存溢出，为什么
如果线程一直在使用，例如线程池中的线程，那么ThreadLocal引用的对象就不能被释放，导致内存泄漏 解决办法就是：在使用ThreadLcal 结束时调用remove 方法 框架 Redis redis 数据结构 String list set zset hash redis 哨兵和集群模式 哨兵模式会有 哨兵服务器来监视 所有节点，检测健康，当主节点宕机之后，哨兵负责选举出新的主节点"><meta property="og:type" content="article"><meta property="og:url" content="https://lilecloud.github.io//posts/java%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-12T09:02:28+08:00"><meta property="article:modified_time" content="2024-08-12T09:02:28+08:00"><meta itemprop=name content="Java面试题"><meta itemprop=description content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别
sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 sleep 可以在任何地方被调用，wait只能在同步代码块中被调用 synchronized 关键字如何实现的
monitor 对象，加锁是monitorenter ,解锁是monitorexit 强引用，弱引用,虚引用，软引用
强引用： 内存不够的时候也不会释放，哪怕发生OOM 软引用：内存不够时GC就会释放 弱引用: 只要是GC 就会释放 虚引用：是最弱的引用，对对象无感有和没有一样，主要用来判断对象鉴活的应用，可以用来做对外内存的释放 ThreadLocal 会导致内存溢出，为什么
如果线程一直在使用，例如线程池中的线程，那么ThreadLocal引用的对象就不能被释放，导致内存泄漏 解决办法就是：在使用ThreadLcal 结束时调用remove 方法 框架 Redis redis 数据结构 String list set zset hash redis 哨兵和集群模式 哨兵模式会有 哨兵服务器来监视 所有节点，检测健康，当主节点宕机之后，哨兵负责选举出新的主节点"><meta itemprop=datePublished content="2024-08-12T09:02:28+08:00"><meta itemprop=dateModified content="2024-08-12T09:02:28+08:00"><meta itemprop=wordCount content="118"><meta itemprop=keywords content="面试,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java面试题"><meta name=twitter:description content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别
sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 sleep 可以在任何地方被调用，wait只能在同步代码块中被调用 synchronized 关键字如何实现的
monitor 对象，加锁是monitorenter ,解锁是monitorexit 强引用，弱引用,虚引用，软引用
强引用： 内存不够的时候也不会释放，哪怕发生OOM 软引用：内存不够时GC就会释放 弱引用: 只要是GC 就会释放 虚引用：是最弱的引用，对对象无感有和没有一样，主要用来判断对象鉴活的应用，可以用来做对外内存的释放 ThreadLocal 会导致内存溢出，为什么
如果线程一直在使用，例如线程池中的线程，那么ThreadLocal引用的对象就不能被释放，导致内存泄漏 解决办法就是：在使用ThreadLcal 结束时调用remove 方法 框架 Redis redis 数据结构 String list set zset hash redis 哨兵和集群模式 哨兵模式会有 哨兵服务器来监视 所有节点，检测健康，当主节点宕机之后，哨兵负责选举出新的主节点"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=// class="f3 fw2 hover-white no-underline white-90 dib">Lilecloud Site</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Java面试题</h1><time class="f6 mv4 dib tracked" datetime=2024-08-12T09:02:28+08:00>August 12, 2024</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=一java-基础>一、Java 基础</h1><h3 id=java-内存模型java-memory-model>Java 内存模型(Java Memory model)</h3><p>JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。
Java 线程之间的通信是由JMM控制的</p><p>JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p><pre tabindex=0><code class=language-ad-question data-lang=ad-question>如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？

应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享
</code></pre><p>![[Pasted image 20240812093554.png]]</p><h4 id=如何控制变量在多线程之间共享>如何控制变量在多线程之间共享</h4><ol><li>加锁：synchronized 关键，手动Lock等</li><li>volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中</li></ol><h4 id=java-并发编程>Java 并发编程</h4><ol><li><p>sleep 和 wait 方法的 区别</p><ul><li>sleep 是属于 Thread 类的，wait 是属于Object累的</li><li>sleep 不会释放锁， wait 会释放锁</li><li>sleep 可以在任何地方被调用，wait只能在同步代码块中被调用</li></ul></li><li><p>synchronized 关键字如何实现的</p><ul><li>monitor 对象，加锁是monitorenter ,解锁是monitorexit</li></ul></li><li><p>强引用，弱引用,虚引用，软引用</p><ul><li>强引用： 内存不够的时候也不会释放，哪怕发生OOM</li><li>软引用：内存不够时GC就会释放</li><li>弱引用: 只要是GC 就会释放</li><li>虚引用：是最弱的引用，对对象无感有和没有一样，主要用来判断对象鉴活的应用，可以用来做对外内存的释放</li></ul></li><li><p>ThreadLocal 会导致内存溢出，为什么</p></li></ol><pre tabindex=0><code class=language-ad-important data-lang=ad-important>如果线程一直在使用，例如线程池中的线程，那么ThreadLocal引用的对象就不能被释放，导致内存泄漏

解决办法就是：在使用ThreadLcal 结束时调用remove 方法
</code></pre><h1 id=框架>框架</h1><h3 id=redis>Redis</h3><h3 id=redis-数据结构>redis 数据结构</h3><ol><li>String</li><li>list</li><li>set</li><li>zset</li><li>hash</li></ol><h3 id=redis-哨兵和集群模式>redis 哨兵和集群模式</h3><p>哨兵模式会有 哨兵服务器来监视 所有节点，检测健康，当主节点宕机之后，哨兵负责选举出新的主节点<br>集群模式 会将分为不同的hash槽，将不同槽对应不同的机器，然后根据key去路由到指定槽里，减轻单台服务器的压力</p><pre tabindex=0><code class=language-ad-question data-lang=ad-question>如果临时增加进来一个服务器怎么办？

会发生rehash，然后讲对应槽上的数据迁移过来
</code></pre><ol start=3><li>如何解决缓存穿透</li></ol><p><a href=https://zhuanlan.zhihu.com/p/58224918>https://zhuanlan.zhihu.com/p/58224918</a></p><p><strong>缓存穿透</strong>就是，就是某些不在缓存中的key，导致不走缓存，被直接打上mysql，数据库压力过大。这里可以使用布隆过滤器，布隆过滤器的特点就是不存在的数据肯定返回不存在，存在的数据数据有可可能不存在</p><ol start=4><li>如何解决缓存雪崩</li></ol><p><strong>缓存雪崩</strong>就是 我们key设置的过期时间一样，导致在同一时间我们热点数据几乎同时失效导致，请求直接打到了数据库造成数据库压力大。</p><p>这个我们可以在设置过期时间时，加上一个随机数来使过期时间趋于分散，不会在同一时间失效</p><ol start=5><li>如何解决缓存击穿</li></ol><p>和缓存雪崩大体一致，区别是缓存雪崩是大量的key，而缓存击穿是某一个key,当某个非常常用的热点数据过期的时候，此时恰好有大量的请求过来，发现缓存过期的时候就会直接访问数据库，导致在重新设置缓存之前有大量的请求进入数据库，导致数据库压力过大。</p><p>可以加锁，获取缓存时只有一个请求去获取</p><ol start=2><li><p>CAP理论</p></li><li><p>c: consistece 一致性</p></li><li><p>a: avaliable 可用性</p></li><li><p>p: partition tolerence 分区容忍</p></li></ol><h3 id=zookeeper>zookeeper</h3><ol><li><p>选举策略 <a href=https://zhuanlan.zhihu.com/p/100938553>https://zhuanlan.zhihu.com/p/100938553</a></p></li><li><p>首先进入leader选举</p></li><li><p>先比较服务的 zxid（全局事务id） 最大的胜出，若相同然后比较 当前服务的id,id大的胜出，如果选举过半则直接成为leader，未过半则等待下一台服务加入进来</p></li></ol><h3 id=kafka>kafka</h3><ol><li>如果保持不会丢消息</li></ol><pre tabindex=0><code class=language-ad-info data-lang=ad-info> producer在生产消息时设置必须等到所有节点都写入才会返回消息发送成功，也可以调整最小节点的数量
 consumer 在消费消息的时候修改自动提交任务为手动提交任务，防止消息消费完后自动消费因网络抖动等原因导致的消费完成后未提交commit
</code></pre><ol start=2><li>如何保证不会重复消费</li></ol><pre tabindex=0><code class=language-ad-info data-lang=ad-info>加一条位置的消息id，消费端来去重
</code></pre><ol start=3><li>如何分区</li></ol><pre tabindex=0><code class=language-ad-info data-lang=ad-info>可以指定分区，或者指定key分区，根据key进行hash来分区
</code></pre><ul class=pa0><li class="list di"><a href=/tags/%E9%9D%A2%E8%AF%95/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">面试</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://lilecloud.github.io//>&copy; Lilecloud Site 2024</a><div><div class=ananke-socials></div></div></div></footer></body></html>
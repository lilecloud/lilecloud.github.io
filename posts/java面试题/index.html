<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Java面试题 | Lilecloud Site</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别 sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 "><meta name=generator content="Hugo 0.104.3"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="Java面试题"><meta property="og:description" content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别 sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 "><meta property="og:type" content="article"><meta property="og:url" content="https://lilecloud.github.io//posts/java%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-12T09:02:28+08:00"><meta property="article:modified_time" content="2024-08-12T09:02:28+08:00"><meta itemprop=name content="Java面试题"><meta itemprop=description content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别 sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 "><meta itemprop=datePublished content="2024-08-12T09:02:28+08:00"><meta itemprop=dateModified content="2024-08-12T09:02:28+08:00"><meta itemprop=wordCount content="41"><meta itemprop=keywords content="面试,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java面试题"><meta name=twitter:description content="一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别 sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁 "></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=// class="f3 fw2 hover-white no-underline white-90 dib">Lilecloud Site</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Java面试题</h1><time class="f6 mv4 dib tracked" datetime=2024-08-12T09:02:28+08:00>August 12, 2024</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=一java-基础>一、Java 基础</h1><h3 id=java-内存模型java-memory-model>Java 内存模型(Java Memory model)</h3><p>JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。
Java 线程之间的通信是由JMM控制的</p><p>JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p><pre tabindex=0><code class=language-ad-question data-lang=ad-question>如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？

应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享
</code></pre><p>![[Pasted image 20240812093554.png]]</p><h4 id=如何控制变量在多线程之间共享>如何控制变量在多线程之间共享</h4><ol><li>加锁：synchronized 关键，手动Lock等</li><li>volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中</li></ol><h4 id=java-并发编程>Java 并发编程</h4><ol><li>sleep 和 wait 方法的 区别<ul><li>sleep 是属于 Thread 类的，wait 是属于Object累的</li><li>sleep 不会释放锁， wait 会释放锁</li><li></li></ul></li></ol><ul class=pa0><li class="list di"><a href=/tags/%E9%9D%A2%E8%AF%95/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">面试</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://lilecloud.github.io//>&copy; Lilecloud Site 2024</a><div><div class=ananke-socials></div></div></div></footer></body></html>
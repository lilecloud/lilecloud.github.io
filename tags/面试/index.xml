<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试 on Lilecloud Site</title><link>https://lilecloud.github.io//tags/%E9%9D%A2%E8%AF%95/</link><description>Recent content in 面试 on Lilecloud Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 12 Aug 2024 09:02:28 +0800</lastBuildDate><atom:link href="https://lilecloud.github.io//tags/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Java面试题</title><link>https://lilecloud.github.io//posts/java%E9%9D%A2%E8%AF%95%E9%A2%98/</link><pubDate>Mon, 12 Aug 2024 09:02:28 +0800</pubDate><guid>https://lilecloud.github.io//posts/java%E9%9D%A2%E8%AF%95%E9%A2%98/</guid><description>一、Java 基础 Java 内存模型(Java Memory model) JMM 是一组抽象的概念不是真实存在，他描述了一组规则或规范，通过这组规范来限定程序中变量的访问方式。Java 是基于虚拟机运行，在虚拟机规范中，定义了一组规范来屏蔽掉硬件以及不同操作系统之间对访问内存的差异，使得Java程序在跨平台中内存访问得到一致。 Java 线程之间的通信是由JMM控制的
JVM运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，其主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存复制到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储这主内存中的变量副本拷贝，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
如果一个对象只是这个线程私有的，那么他会被分配到主内存还是仅仅在该线程的工作内存？ 应该是分配在主内存，因为生成对象的时候并不知道该对象是否会被线程共享 ![[Pasted image 20240812093554.png]]
如何控制变量在多线程之间共享 加锁：synchronized 关键，手动Lock等 volatile：volatile 关键字实现了MESI(缓存一致性协议)，可以让共享变量的变更体现在各个线程中 Java 并发编程 sleep 和 wait 方法的 区别 sleep 是属于 Thread 类的，wait 是属于Object累的 sleep 不会释放锁， wait 会释放锁</description></item></channel></rss>